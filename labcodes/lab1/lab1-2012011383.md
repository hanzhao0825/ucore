# 练习1
gcc将.c编译成.o。-l:添加头文件路径。-fno-builtin：不承认不以__builtin_开头的函数为内将函数。-Wall：生成所有警告。-ggdb：生成gdb专用调试信息。-m32:进行32位编译。-gstabs：以stab可是生成调试信息。-nostdinc：事编译器不再系统蛩声头文档目录找头文档。-fno-stack-protector：禁用堆栈保护。-c：只编译不链接。-o：指定输出文件。

ld把.o链接。-m elf_i386：elf格式输出32位文件。-nostdlib：不链接系统标准启动文件和标准库文件。-T：指定自己的链接脚本。-o：指定输出文件。-N：ldconfig不重建缓存文件。-e start：start为入口。-Ttext 0x7c00:已0x7c00地址开始。

dd将二进制文件写到img。if：输入文件。of：输出文件。count：处理数据大小。conv=notrunc：不截断输出文件。seek：输出文件从头跳过若干快。

符合规范的硬盘主引导区特征：最后两个字分别为0x55和0xAA。

# 练习2
单步进入后，在0x7c00加入断点，continue到达断点。此时的汇编代码就是bootasm中的代码。然后跳到bootmain

设置断点0x7cfe，发现就是bootmain处

# 练习3
开启A20是为了将地址变成32位。开启方法：循环等待8042键盘控制器空闲，请求输入数据。被响应后，向0x60端口写入0xdf

GDT表的开头是：空，代码段，数据段。

如何使能：将cr0的第0位改成1。进入保护模式要long jump到32位代码段。

# 练习4
读取扇区：1.等待磁盘 2.输出读取扇区命令 3.等待磁盘 4.读取数据

加载os：读取第一个扇区，得到elfhdr数据。找到os开始的地址，程序段大小和offset。然后将这些程序部分复制到对应的内存位置。

# 练习5
参考注释来完成代码……注意一下输出的格式就好。有一些具体的数字和标准答案有一点点的偏差，可能是因为初始条件有点区别。

和标准代码的实现稍微有一点点差别。不过其实效果是等效的。

最后一句是bootmain调用kern_init的代码所在地址。

# 练习6
一个表项是一个8字节的门描述符。前16位拼上后16为是offset。这就是中断处理代码入口。

初始化idt的时候，我们使用SETGATE来完成。其中对于T_SWITCH_TOK，要给他内核特权。

使用ticks全局变量计数，100次输出一次。
